<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to    </title>
    <meta charset="utf-8" />
    <meta name="author" content="Evangeline Warren" />
    <script src="libs/header-attrs-2.18/header-attrs.js"></script>
    <link rel="stylesheet" href="buckeye.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Introduction to <br/><br/> <img src="img/r-logo.png" width="200" />
]
.author[
### Evangeline Warren
]
.institute[
### R Working Group
]
.date[
### Jan 20th, 2023
]

---





# Goals for this session

* Learn about...

--
    + basic R syntax
    
    + different R objects (things that hold data)
    
    + useful functions for working with data

--
  
* Become familiar with [R Studio](https://posit.co/download/rstudio-desktop/) &amp; 
  develop good coding habits 
  
--
  
    * R Studio is an *additional* program that provides many useful features
    for working with R
    
    * (you need to download and install both [R](https://cran.r-project.org/) and 
    [R Studio](https://posit.co/download/rstudio-desktop/))


---
class: inverse, center, middle

# R Studio


---
# R Studio

* Let's dive in by starting R Studio and opening a new R script

    + menu bar: &amp;nbsp; `File` &amp;rarr; `New File` &amp;rarr; `R Script`
    + (in R: &amp;nbsp; `File` &amp;rarr; `New Script`)
--

* You should now have 4 panes open (like on the next slide)

    + **Source** -- Our script where we will type and save our comments &amp; commands
    + **Console** -- Where we can give R commands and where the output will appear
    + **Output** -- File explorer, plots, help files, and more!
    + **Environments** -- Useful information about the R session


---
.center[&lt;img src="img/rstudio-panes-labeled.jpeg" style="width: 75%" /&gt;]

.center[.bottom[downloaded from [user guide on postit.co](https://docs.posit.co/ide/user/ide/guide/ui/ui-panes.html)]]


---
# R Studio: Good Habits

* Add a comment to our new script:
    
    ```r
    # Comment: My R script from Working Group Session (1/20/2023)
    # (R ignores all lines that begin with a pound/hash/number sign/#)
    ```
--

* Save our script
    + menu bar: &amp;nbsp; `File` &amp;rarr; `Save As...`
--

* Set our **working directory**
    + this is where R will start looking for &amp; saving files (e.g., data files or plots)
    + menu bar: &amp;nbsp; `Session` &amp;rarr; `Set Working Directory` &amp;rarr; `Choose Directory...`


---
class: inverse, center, middle

# Basic R Syntax

---
# Basic R Syntax

* R syntax takes the form


```r
# object_name &lt;- object_value  
mean_age &lt;- 33
```

--

* The symbol `&lt;-` is called the assignment operator

    + we are creating a new variable called `mean_age` and assigning it a value of 33

    + `mean_age = 33` will also work (but `&lt;-` is the convention)


---
class: slide-font-25
# Basic R Syntax (cont.)

If we enter the name of a variable in the `Console`, then R will list the value(s)

```r
&gt; Mean_age2 &lt;- 22  ## note: object names are case-sensitive
&gt; Mean_age2
```

```
## [1] 22
```

--
BUT we are in the business of good habits...

* type this syntax into our script and (with the cursor on the same line) press the following keys together:

    + On a Mac: &amp;nbsp;  `&lt;command&gt; &lt;enter&gt;`
    
    + In Windows: &amp;nbsp: `&lt;control&gt; &lt;enter&gt;` (R Studio)  `&lt;control&gt; r` (plain R)

* these keyboard shortcuts will run the syntax on the line in the `Console` &lt;br&gt; 
(or you can highlight a region)


---
# Basic R Syntax: functions

We have seen a simple object for holding data, but R has many useful **functions**

```r
ls()        # list all the objects in memory
getwd()     # print the working directory
dir()       # list the files in the current directory
dir("../")  # list the files in the parent directory
save.image("my_data.RData")  # save all the objects in memory
load("my_data.RData")        # load all the objects in the data file
```


---
# Basic R Syntax: help files

* Google searches are a very effective way to find help

    + and so is asking the R Working Group :)
--

* R documentation can be accessed in the `Help` tab in the `Output` pane

--

* Some additional syntax and functions

```r
?read.csv  # show the help file for the function read.csv
help.search("weighted mean")  # search help files for the phrase'weighted mean'
```



---

## **Data Structures**: overview

* R has different structures for holding data, which can be 
organized by... 

    + how many dimensions does it have? 
    
      - just a row of values (dim = 1)
      - standard data set of rows and columns (dim = 2) 

    + do the types of data need to be the same? 
  
* We'll now introduce different data structures, and learn about
different data types along the way.


---

## **Data Structures**: overview (continued)

* **Vectors**
  1. 1 dimension
  1. same data type
    + special case: **factor** (predefined categories)

* **Matrices**
  1. rows and columns
  1. same data type

* **Arrays** 
  1. any number of dimensions
  1. same data type

* **Data Frames**
  1. rows and columns
  1. different data types

* **Lists**
  1. 1 dimension
  1. different data types (or structures!)
  - actually, this is just a special type of vector (can you verify this?)


## **Vectors**

Create and explore a **vector**...


```r
&gt; vector1 &lt;- c(5, 2, 8)  # c() for combine elements
&gt; dim(vector1) # get dimensions
```

```
## NULL
```



`dim()` only work if we have 2+ dimensions, so we'll go with


```r
&gt; str(vector1)  # tell us about the structure
```

```
##  num [1:3] 5 2 8
```



We learn about the number of elements (3) and the *data type* (`num` for numeric)


## **Vectors**: accessing elements with addresses

The output from `str` also gives an example of *subsetting* vectors

    + use [ ] to access elements in a vector:


```r
&gt; vector1[1]  # get the first element
```

```
## [1] 5
```




```r
&gt; vector1[c(1, 3)] # get 1st and 3rd elements
```

```
## [1] 5 8
```




```r
&gt; vector1[1:3] # get 1st, 2nd, &amp; 3rd
```

```
## [1] 5 2 8
```

(we'll return to this shortly)


## **Vectors**: data type conversion

Can you explain what is going on here?

  + (*hint*: remember the 2 features of data structures)


```r
&gt; c(vector1, "1")
```

```
## [1] "5" "2" "8" "1"
```


```r
&gt; mean(c(vector1, "1"))
```

```
## Warning in mean.default(c(vector1, "1")): argument is not numeric or logical:
## returning NA
```

```
## [1] NA
```


## **Vectors**: data type conversion (cont.)

* Recall that (normal) vectors are *atomic*, another way of saying that all
the elements must be of the same *data type* 

* In the previous example, R converts all of the elements to the same data type


```r
&gt; str(c(vector1, "1"))
```

```
##  chr [1:4] "5" "2" "8" "1"
```



* Thankfully, R does not know how to take the mean of the data type `chr`
(characters)


## **Vectors**: subsetting &amp; changing values

* So far we have accessed elements in a vector using [ ] and the position (e.g., 1, 2, 3, ... for `\(1^{st}\)`, `\(2^{nd}\)`, `\(3^{rd}\)`, ...) 

* We can also use [*position*] to change elements in a vector


```r
&gt; vector1
```

```
## [1] 5 2 8
```

```r
&gt; vector1[3] &lt;- 29
&gt; vector1
```

```
## [1]  5  2 29
```


* What will this code do?

```r
&gt; vector1[c(1, 2)] &lt;- -9
&gt; vector1[4] &lt;- 56
&gt; vector1[8] &lt;- mean(vector1)
```


## **Vectors**: subsetting &amp; changing values (cont.)

* When you want to change a vector, do the *delta 2-step*: 

  1. create an index vector that identifies the elements you want to change 
  (what data type should this vector hold?... `logical`) 
  
      + `which()` is a very useful tool, be we can also use basic statements
  
  2. assign new values to the vector using you vector of indices


## **Vectors**: subsetting &amp; changing values (cont.)

Suppose we want to change all `NA` values to -9


```r
&gt; x &lt;- c(1, 2, 3, NA, 7, 8, NA)
&gt; x_missing &lt;- is.na(x)
```




```r
&gt; x[x_missing]
```

```
## [1] NA NA
```




```r
&gt; x[x_missing] &lt;- -9
&gt; x
```

```
## [1]  1  2  3 -9  7  8 -9
```


## **Vectors**: subsetting &amp; changing values (cont.)

Suppose we want to change all values below 0 to `NA


```r
&gt; x 
```

```
## [1]  1  2  3 -9  7  8 -9
```

```r
&gt; x[x &lt; 0]
```

```
## [1] -9 -9
```




```r
&gt; x[x &lt; 0] &lt;- NA
&gt; x
```

```
## [1]  1  2  3 NA  7  8 NA
```


## **Vectors**: subsetting &amp; changing values (cont.)

Suppose we want to change the maximum value to 100


```r
&gt; x 
```

```
## [1]  1  2  3 NA  7  8 NA
```

```r
&gt; which(x == max(x, na.rm = TRUE))
```

```
## [1] 6
```




```r
&gt; x_ind_max &lt;- which(x == max(x, na.rm = TRUE))
&gt; x[x_ind_max] &lt;- 100
&gt; x
```

```
## [1]   1   2   3  NA   7 100  NA
```

## **Vectors**: subsetting &amp; changing values (cont.)

We can also use multiple conditions

 * to satisfy BOTH conditions use `&amp;` (and)
 * to satisfy EITHER condition use `|` (or)


```r
&gt; x_index_new &lt;- is.na(x) | x &gt; 7
&gt; x[x_index_new]
```

```
## [1]  NA 100  NA
```




```r
&gt; y &lt;- -10:10
&gt; y_index &lt;- y &gt; -3 &amp; y &lt; 3
&gt; y[y_index]
```

```
## [1] -2 -1  0  1  2
```


## **Vectors**: subsetting &amp; changing values (cont.)

What is wrong?


```r
&gt; y &lt;- 1:6
&gt; y[y &lt; 3] &lt;- c(0, 1, 2)
```

```
## Warning in y[y &lt; 3] &lt;- c(0, 1, 2): number of items to replace is not a multiple
## of replacement length
```

## **Data Structures**: *Matrix*


```r
&gt; # cbind() - combine vectors as columns
&gt; Mat1 &lt;- cbind( c(1:2), c(3:4), c(5:6) )
&gt; Mat1
```

```
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
```

```r
&gt; # rbind() - combine vectors as rows
&gt; Mat2 &lt;- rbind( c(1:2), c(3:4), c(5:6) )
&gt; Mat2
```

```
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## [3,]    5    6
```


## **Getting to Know Your Matrix**

* With vectors, we used `vector1[i]` to access the
`\(i^{th}\)` element.

* With matrices, the location of an element has 2 parts: *row* &amp; *column*

* Suppose, `coolMatrix` is a 10 by 10 matrix.  We can access
  the element in the `\(3^{rd}\)` row and the `\(8^{th}\)` column as follows...

    + `coolmatrix[3, 8]`

* Excluding the row will return an entire column

    + `coolMatrix[, 8]`
    
    + or you can get part of a column
    
      `coolMatrix[c(3:5), 8]`


## **Getting to Know Your Matrix** (cont.)


```r
&gt; dim(Mat1)
```

```
## [1] 2 3
```

```r
&gt; str(Mat1)
```

```
##  int [1:2, 1:3] 1 2 3 4 5 6
```

```r
&gt; nrow(Mat1)
```

```
## [1] 2
```

```r
&gt; ncol(Mat1)
```

```
## [1] 3
```

## **Getting to Know Your Matrix** (cont.)
  

```r
&gt; Mat2[1, 1]
```

```
## [1] 1
```

```r
&gt; Mat2[2, ]
```

```
## [1] 3 4
```

```r
&gt; t(Mat2)
```

```
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
```

## **Getting to Know Your Matrix** (cont.)


```r
&gt; apply(Mat2, 1, mean)
```

```
## [1] 1.5 3.5 5.5
```
  

```r
&gt; colMeans(Mat2)
```

```
## [1] 3 4
```

```r
&gt; rowMeans(Mat2)
```

```
## [1] 1.5 3.5 5.5
```
  
## **Exercises**: vectors &amp; matrices

* Provide an example of data type conversion with a matrix

* How do you print out the first row of Mat2?

* Replace the diagonal elements in Mat1 with zeros.

* Why does the following code give an Warning message?
    
    ```r
    &gt; M1 &lt;- rbind( c("a", "b"), c("d", "e") )
    &gt; cbind( M1, c("1", "2", "3") )
    ```

* Find another R function for creating a matrix, and provide an example.

* Create a 2 x 6 matrix called Mat21 that combines `Mat1` and `t(Mat2)`.


## **Data Structures**: *Data Frames*

* **Data frames** are R structure for typical data sets (i.e.,
variables as columns and an observation for each row). 

  + `read.csv()` -- read in a CSV file (the resulting object 
    will be a data frame)

** The same process for accessing elements in a matrix also works
for data frames

  + With data frames we can also use [[ ]] or $*column_names* to access
  a column
    - with [[ ]] we can use either the columns position or characters
    - (what is the difference between [[ ]] and ?)


## **Data Frames**: exploring columns


```r
&gt; is.data.frame(mtcars)
```

```
## [1] TRUE
```

```r
&gt; names(mtcars)
```

```
##  [1] "mpg"  "cyl"  "disp" "hp"   "drat" "wt"   "qsec" "vs"   "am"   "gear"
## [11] "carb"
```


## **Data Frames**: exploring columns (cont.)


```r
&gt; str(mtcars)  ## print structure of data frame
```

```
## 'data.frame':	32 obs. of  11 variables:
##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
##  $ disp: num  160 160 108 258 360 ...
##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
##  $ qsec: num  16.5 17 18.6 19.4 17 ...
##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
```


## **Data Frames**: exploring columns (cont.)


```r
&gt; mtcars[[1]]
```

```
##  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
## [31] 15.0 21.4
```


## **Data Frames**: exploring columns (cont.)


```r
&gt; mtcars[["mpg"]]
```

```
##  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
## [31] 15.0 21.4
```


```r
&gt; is.vector(mtcars[["mpg"]])
```

```
## [1] TRUE
```

What does this do?


```r
&gt; mtcars$mpg[10] &lt;- "a"
```

## **Data Frames**: exploring columns (cont.)

What does this do?


```r
&gt; jt &lt;- "mpg"
&gt; mtcars[[jt]]
```


## **Data Frames**: exploring columns (cont.)



```r
&gt; mtcars$mpg[1:2]           ## access variable with $
```

```
## [1] "21" "21"
```

```r
&gt; summary(mtcars$mpg)       ## summarize variable
```

```
##    Length     Class      Mode 
##        32 character character
```

```r
&gt; ## summary(mtcars)             ## summarize all variables
&gt; mtcars$NewVar &lt;- 1:nrow(mtcars)  ## create new variable
&gt; names(mtcars)
```

```
##  [1] "mpg"    "cyl"    "disp"   "hp"     "drat"   "wt"     "qsec"   "vs"    
##  [9] "am"     "gear"   "carb"   "NewVar"
```


# Extra Slides

## more

* named vectors, seq, rep
* `which` (and `which.max`)
* na.rm option
* `apply` and `lapply`
* `subset` is a very useful command (more on this)



## Data Structures: exercises with vectors

* Create a new vector called vector4 that is exactly the same
as vector3.

* Create a new vector called vector5 that is exactly the same as 
vector3 but includes the string "IPR" at the end (i.e., as the 9th 
element).

* What does the function **`seq()`** do? Use this
function in two different ways.

* What does the function **`rep()`** do?  Use this function in two
different ways.

* Make a vector with elements 100, 99, ..., -98, -99, -100. Please,
please, please, please do not type in each individual number.


## Data Structures: getting to know your vector 

**A few useful tools when working with vectors**

* List info about data structure: `str()`
    
    ```r
    &gt; str(1:100)
    ```
    
    ```
    ##  int [1:100] 1 2 3 4 5 6 7 8 9 10 ...
    ```


* Number of elements: `length()`
    
    ```r
    &gt; length(1:100)
    ```
    
    ```
    ## [1] 100
    ```

* sort and order

## Data Structures: getting to know your vector (cont.)

* view particular elements in the vector, e.g, get the second element
    
    ```r
    &gt; vector1; vector1[2]
    ```
    
    ```
    ## [1]  5  2 29
    ```
    
    ```
    ## [1] 2
    ```


* we can also create **named vectors**
    
    ```r
    &gt; v6 &lt;- c("OH" = 120000, "WA" = 7)
    &gt; v6
    ```
    
    ```
    ##     OH     WA 
    ## 120000      7
    ```


## Data Structures: getting to know your vector (cont.)

* Alternatively, we can add names to an existing vector
    
    ```r
    &gt; names(vector1)
    ```
    
    ```
    ## NULL
    ```
    
    ```r
    &gt; names(vector1) &lt;- letters[1:5]
    ```
    
    ```
    ## Error in names(vector1) &lt;- letters[1:5]: 'names' attribute [5] must be the same length as the vector [3]
    ```
    
    ```r
    &gt; vector1
    ```
    
    ```
    ## [1]  5  2 29
    ```
    
    ```r
    &gt; attributes(vector1)
    ```
    
    ```
    ## NULL
    ```



## Data Structures: `factor` (special kind of vector)

* A `factor` has predefined values for categorical data

    + There are ordered and unordered `factors`

* The function: `factor()` includes arguments...

    + `x` - the actual data

    + `levels` - the predefined values
  
    + `labels` - informative names for the `levels`


## Data Structures: `factor` (continued)


```r
&gt; z &lt;- factor( x = c(0,0,1,1,2),
+              levels = 0:2,
+              labels = c("neonate",
+                         "child",
+                         "adult"))
&gt; is.factor(z)
```

```
## [1] TRUE
```

```r
&gt; z
```

```
## [1] neonate neonate child   child   adult  
## Levels: neonate child adult
```

```r
&gt; levels(z)
```

```
## [1] "neonate" "child"   "adult"
```


## Data Structures: creating matrices


```r
&gt; # cbind() - combine vectors as columns
&gt; Mat1 &lt;- cbind( c(1:2), c(3:4), c(5:6) )
&gt; Mat1
```

```
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
```

```r
&gt; # rbind() - combine vectors as rows
&gt; Mat2 &lt;- rbind( c(1:2), c(3:4), c(5:6) )
&gt; Mat2
```

```
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## [3,]    5    6
```


## Data Structures: getting to know your matrices

* With vectors, we used `vector1[i]` to access the
`\(i^{th}\)` element.

* With matrices, the location of an element has 2 parts: *row* &amp; *column*

* Suppose, `coolMatrix` is a 10 by 10 matrix.  We can access
  the element in the $3^{rd} row and the $8^{th} column as follows...

    + `coolmatrix[3, 8]`

* Excluding the row will return an entire column

    + `coolMatrix[, 8]`
    
    + or you can get part of a column
    
      `coolMatrix`[c(3:5), 8]


## Data Structures: getting to know your matrices

  
  ```r
  &gt; dim(Mat1)
  ```
  
  ```
  ## [1] 2 3
  ```
  
  ```r
  &gt; str(Mat2)
  ```
  
  ```
  ##  int [1:3, 1:2] 1 3 5 2 4 6
  ```
  
  ```r
  &gt; nrow(Mat2)
  ```
  
  ```
  ## [1] 3
  ```
  
  ```r
  &gt; ncol(Mat2)
  ```
  
  ```
  ## [1] 2
  ```
  
  
  ```r
  &gt; Mat2[1, 1]
  ```
  
  ```
  ## [1] 1
  ```
  
  ```r
  &gt; Mat2[2,]
  ```
  
  ```
  ## [1] 3 4
  ```
  
  ```r
  &gt; t(Mat2)
  ```
  
  ```
  ##      [,1] [,2] [,3]
  ## [1,]    1    3    5
  ## [2,]    2    4    6
  ```
  
## Data Structures: exercises for vectors &amp; matrices

* How do you print out the first row of Mat2?

* Replace the diagonal elements in Mat1 with zeros.

* Why does the following code give an Warning message?
    
    ```r
    &gt; M1 &lt;- rbind( c("a", "b"), c("d", "e") )
    &gt; cbind( M1, c("1", "2", "3") )
    ```

* Find another R function for creating a matrix, and provide an example.

* Create a 2 x 6 matrix called Mat21 that combines `Mat1` and `t(Mat2)`.


## Data Structures: data frames intro

* **Data frames** are R structure for typical data sets (i.e.,
variables as columns and an observation for each row). 

* To explore data frames we are going to use a new function.

    + `read.csv()` -- read in a CSV file (the resulting object 
    will be a data frame)
    
* `subset` is a very useful command (more on this)


## Data Structures: data frames example


```r
&gt; dir()
```

```
## [1] "buckeye.css"  "img"          "intro_r.html" "intro_r.Rmd"  "libs"
```

```r
&gt; data(cars)
&gt; is.vector(cars)
```

```
## [1] FALSE
```

```r
&gt; is.factor(cars)
```

```
## [1] FALSE
```

```r
&gt; is.matrix(cars)
```

```
## [1] FALSE
```

```r
&gt; is.data.frame(cars)
```

```
## [1] TRUE
```


## Data Structures: data frames example (continued)

**A few useful tools to work with data frames...**


```r
&gt; str(cars)  ## print structure of data frame
```

```
## 'data.frame':	50 obs. of  2 variables:
##  $ speed: num  4 4 7 7 8 9 10 10 10 11 ...
##  $ dist : num  2 10 4 22 16 10 18 26 34 17 ...
```


## Data Structures: data frames example (continued)

**A few useful tools to work with data frames...***


```r
&gt; names(cars)  ## list variable names
```

```
## [1] "speed" "dist"
```

```r
&gt; dim(cars)    ## dimensions (rows, columns)
```

```
## [1] 50  2
```

```r
&gt; newDFrame &lt;- as.data.frame(Mat1)  ## convert matrix to d.f.
&gt; newDFrame
```

```
##   V1 V2 V3
## 1  1  3  5
## 2  2  4  6
```


## Data Structures: data frames example (continued)

**A few useful tools to work with data frames...**


```r
&gt; cars$speed[1:2]           ## access variable with $
```

```
## [1] 4 4
```

```r
&gt; summary(cars$speed)       ## summarize variable
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##     4.0    12.0    15.0    15.4    19.0    25.0
```

```r
&gt; ## summary(cars)             ## summarize all variables
&gt; cars$NewVar &lt;- 1:nrow(cars)  ## create new variable
&gt; names(cars)
```

```
## [1] "speed"  "dist"   "NewVar"
```


## Data Structures: data frame exercises

* Summarize the `dist` variable and describe the values.

* Write an R command that prints out the 7th, 12th, and 33rd 
state names.


## Data Structures: lists

* What are the characteristics of a `list` in R

  
  ```r
  &gt; newList &lt;- list(
  +   v1 = c("a", "b", "c"), 
  +   v2 = 1:4
  +   )
  &gt; newList
  ```
  
  ```
  ## $v1
  ## [1] "a" "b" "c"
  ## 
  ## $v2
  ## [1] 1 2 3 4
  ```
  
  ```r
  &gt; newList$v1
  ```
  
  ```
  ## [1] "a" "b" "c"
  ```


## Data Structures: lists (cont.)  



  
  ```r
  &gt; newList$v2
  ```
  
  ```
  ## [1] 1 2 3 4
  ```
  
  ```r
  &gt; newList$v3 &lt;- c(
  + "x", "y", "z"
  + )
  &gt; newList
  ```
  
  ```
  ## $v1
  ## [1] "a" "b" "c"
  ## 
  ## $v2
  ## [1] 1 2 3 4
  ## 
  ## $v3
  ## [1] "x" "y" "z"
  ```
  
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
